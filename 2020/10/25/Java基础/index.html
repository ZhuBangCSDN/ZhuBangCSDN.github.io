<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Java基础 | Blog of Alaga 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="朱邦政">
    
    

    <meta name="description" content="基础知识&#x3D;&#x3D;代理、反射和多态&#x3D;&#x3D;- &#x3D;&#x3D;equals 和(&#x3D;&#x3D;)和 hashcode&#x3D;&#x3D; &#x3D;&#x3D;我们在用的时候，如果比较的是基本数据类型，比较的就是它们的值，如果比较的是引用数据类型，那我们比较的就是对象的的地址是否一致，equals 的话，不能对基本数据类型进行比较，在没有重写 equals 方法的时候其实和&#x3D;&#x3D;一样，比较的是对象的地址，但是我们可以通过从重写 equals 方法来让它比较两个对象">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础 | Blog of Alaga">
<meta property="og:url" content="http://yoursite.com/2020/10/25/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Blog of Alaga">
<meta property="og:description" content="基础知识&#x3D;&#x3D;代理、反射和多态&#x3D;&#x3D;- &#x3D;&#x3D;equals 和(&#x3D;&#x3D;)和 hashcode&#x3D;&#x3D; &#x3D;&#x3D;我们在用的时候，如果比较的是基本数据类型，比较的就是它们的值，如果比较的是引用数据类型，那我们比较的就是对象的的地址是否一致，equals 的话，不能对基本数据类型进行比较，在没有重写 equals 方法的时候其实和&#x3D;&#x3D;一样，比较的是对象的地址，但是我们可以通过从重写 equals 方法来让它比较两个对象">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-10-24T16:32:59.000Z">
<meta property="article:modified_time" content="2020-10-24T16:38:40.316Z">
<meta property="article:author" content="朱邦政">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    
<link rel="stylesheet" href="/css/uno.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    
<link rel="stylesheet" href="/css/archive.css">

    
<link rel="stylesheet" href="/css/china-social-icon.css">


<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Blog of Alaga" type="application/atom+xml">
</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Blog of Alaga</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->




        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Java基础</h1>

    

    <div class="post-meta">
      <time datetime="2020-10-25" class="post-meta__date date">2020-10-25</time> 

      <span class="post-meta__tags tags">

          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/Java/">Java</a>
            </font>
          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/Java/" rel="tag">Java</a>, <a class="tags-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a>, <a class="tags-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="代理、反射和多态"><a href="#代理、反射和多态" class="headerlink" title="==代理、反射和多态=="></a>==代理、反射和多态==</h3><p>-</p>
<h3 id="equals-和-和-hashcode"><a href="#equals-和-和-hashcode" class="headerlink" title="==equals 和(==)和 hashcode=="></a>==equals 和(==)和 hashcode==</h3><ul>
<li>==我们在用的时候，如果比较的是基本数据类型，比较的就是它们的值，如果比较的是引用数据类型，那我们比较的就是对象的的地址是否一致，equals 的话，不能对基本数据类型进行比较，在没有重写 equals 方法的时候其实和==一样，比较的是对象的地址，但是我们可以通过从重写 equals 方法来让它比较两个对象的值，重写 equals 通常有必要重写 hashcode 方法。hashcode 就是把对象的地址通过计算返回一个整数，它是针对散列存储结构的，比如 hashmap、hashset、hashtable 这些，我们比较对象的时候就是先比较它的 hashcode 是否相等，如果相等再进一步判断地址是否相等，如果 hashcode 都不相等，那这两个对象肯定就不相等了。</li>
</ul>
<h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="==自动装箱和拆箱=="></a>==自动装箱和拆箱==</h3><h3 id="StringBuffer-和-StringBuilder"><a href="#StringBuffer-和-StringBuilder" class="headerlink" title="StringBuffer 和 StringBuilder"></a>StringBuffer 和 StringBuilder</h3><hr>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="==ArrayList 和 LinkedList 的区别=="></a>==ArrayList 和 LinkedList 的区别==</h3><ul>
<li>ArrayList 底层是一个 object 数组，而 LinkedList 是一个双向链表，ArrayList 在知道 index 情况下查询和修改是效率最高的，而 LinkedList 则需要从头到尾遍历节点进行查询，但是在增加和删除的时候，ArrayList 默认是插入到最后一位，如果我们指定了中间的某个位置 ArrayList 就需要开辟新的数组，然后移动把指定插入位置后的元素都往后移一位，然后再插入，开销比较大，而实际上 LinkedList 在插入的时候也只有头插和尾插快，如果是在中间插入的话，还是要一个一个遍历节点找到位置然后插入，开销远比 ArrayList 大，只有它的头插是比 ArrayList 的头插快的多的。除此之外 LinkedList 要消耗更多的空间来存放前驱后继数据等。然后这两个 Collection 都是线程不安全的。</li>
<li>如果是想要线程安全的话，有一个比较老土的方法是 Vector，它的所有方法都上了锁，实现了同步，一个线程访问 Vector 的时候要进行同步会产生的开销很大，所以现在用的比较少了。</li>
</ul>
<hr>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="==HashMap=="></a>==HashMap==</h3><ul>
<li>HashMap 是我比较常用的一个集合，是由数组加上链表的结构组成的，实际上也可以说它是一个数组，使用了拉链发加上链表来解决哈希冲突的问题。在 java1.7 的时候是数组加上链表，然后使用的是头插法，1.8 的时候改成了数组加上链表加上红黑树的结构，采用的是尾插法。因为使用头插法在 rehash 和 resize 的过程中会出现 null 值得丢失，会出现死循环。1.8 的 HashMap 在链表的长度超过 8 也就是默认阈值的时候会自动转成红黑树，提高了效率。</li>
<li>HashMap 的扩容机制是这样的，它的默认容量是 16，负载因子是 0.75，当存储的数量达到容量乘上负载因子的时候就会触发扩容，也就是说 16×0.75=12 的时候出触发扩容。扩容的时候就是创建一个新的数组，容量是容量是之前的两倍，再把所有的元素的 Hash 值都重新计算也就是 rehash 的过程，最后放进新的 HashMap 里。</li>
<li>HashMap 是线程不安全的，如果涉及到线程安全的话，HashTable 和 ConcurrentHashMap 都是线程安全的，但是 HashTable 现在已经基本弃用了，它的所有方法都经过了 synchronized 修饰，它用的是全表锁，就是一把锁锁整张表，如果有一个线程访问的时候，其他线程是不能访问的，只能进入阻塞或者轮询的状态，效率非常低。而 ConcurrentHashMap 在 jdk1.7 的时候采取了分段锁，是由 Segment 和 HashEntry 组成的，Segment 实现了 ReentrantLock，HashEntry 是一个链表结构的元素，整个看起来有点像 HashMap，只不过 Segment 是带了锁的，当我们要对 Entry 里面的元素进行修改时，首先要获得 Segment 的锁。然后在 1.8 的时候 ConcurrentHashMap 就取消了 segment 分段锁，改成了 CAS 加上 synchronized 来实现线程安全，它的数据结构也就变成了数组加链表加红黑树的结构，跟 HashMap 类似，链表长度超过 8 的时候就把链表转化为红黑树，synchronized 锁住了链表或者红黑树的头节点，这样只要不发生 hash 冲突就不会产生并发，效率提高了很多。</li>
<li>Hash 冲突是指我们在计算 Hash 值的时候可能会出现相同的情况，而 HashMap 采用拉链法解决这种问题，如果计算出 Hash 值重复就判断当前位置的 key 是否相同，如果相同的话就直接覆盖，不同的话再用链表的形式存储。HashMap 长度是 2 的倍数的原因则是 hash 值的范围太大，内存放不下，我们是对其进行取模运算，就是 n-1&amp;hash，这是 HashMap 长度是 2 的倍数的原因。</li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="==Hash=="></a>==Hash==</h3><ul>
<li>Hash 就是一种转换方法，把任意长度的输入通过一定的计算方法转换成固定长度的输出。解决 Hash 冲突的方法有四种，一个是开放定址法，就是为产生冲突的地址求一个地址序列，即把它放到后面的地址上去（线性探测，平方探测，随机探测）一个是 HashMap 里的链表散列法，如果遇到相同的 Hash 地址，就按链表来连接。一个是再哈希，就是重新计算 hash 值直到不冲突为止。还有一个就是计算公共溢出区，把冲突的都放在一个地方，不在表里。</li>
<li>Hash 的一些使用：涉及到分布式的系统，就会有负载均衡和数据分布的问题。1、Hash 取模，比如有三台服务器，我们要做负载均衡，就可以把请求的用户的 ip 地址计算出 hash 值，然后对 3 取模，余数为几就放到哪台服务器上。缺点就是如果新增了服务器，那所有的绝大多数的请求都要重新映射，变动太大了。2、一致性 Hash，一致性哈希是以 2^32 为除数来取模，从 0 到 2^32-1 来形成一个环。我们先对服务器地址进行 Hash 计算，然后对 2^32 求余，得到它在环中的位置，然后来了一个请求，用同样的方式计算它在环中的位置，然后顺时针找到第一个节点，这个节点就处理这个请求。缺点就是节点数量比较少的时候会出现分布不均匀的情况，解决的办法是在 Hash 环上增加虚拟节点。</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="==HashSet=="></a>==HashSet==</h3><ul>
<li>HashSet 它是一个由 HashMap 支持的容器，它存储唯一元素不允许为空值，并且不保证顺序插入，其实就是一个皮包公司，它对外接活，接到了就丢给 HashMap 处理，可以理解为是 HashMap 的包装，比如它的 add 方法就是基于 HashMap 的 put 方法实现的，只不过 HashMap 是 kv 存储，而 HashSet 是存储对象的，它把对象储存在 HashMap 的 key 上，value 值默认为空，除此之外它的 remove 方法、contains 方法，还有其它的一些方法，都是基于 HashMap 来实现的，因为是把对象存储在 key 上，所以 HashSet 内部的元素是无序的，如果要有序的话可以使用 LinkedHashSet。</li>
</ul>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="==CopyOnWriteArrayList=="></a>==CopyOnWriteArrayList==</h3><ul>
<li>它其实就是运用了写入时复制（CopyOnWrite，简称 COW）思想，就是如果有多个调用者对同一份资源呢进行操作的时候他们会获取相同的指针指向同一份资源，当进行修改时系统会创建一份专用副本给这个调用者，而其他调用者见到的还是初始的资源不变。CopyOnWriteArrayList 在 add 的时候就是，在方法的最前面加了锁，这里用了 ReentrantLock，然后创建副本数组进行操作，这样才能保证只创建单个副本，而读的时候不需要加锁，即便有多个线程进行写操作读到的还是旧数据。它内部有一个用 volatile transient 修饰的数组，一个线程在读取数组的时候总能看到其他数组对这个数组最后的写入，这样就保证了 add 前后的一致性，但是 CopyOnWriteArrayList 也有缺点，缺点在于内存占用比较大，并且只能保证数据的最终一致性，不能保证实时一致性。</li>
</ul>
<hr>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><ul>
<li>进程时程序的一次执行过程，它是系统进行资源调度和分配的基本单位，进程的实体是由程序段数据段还有 PCB 块组成的，创建进程实际上就是创建实体对应的 PCB 块，撤销就是撤销 PCB 块。而线程是比进程更小的资源调用单位，也可以说是轻型进程，一个进程中可以拥有多个线程，与进程不同的地方在于线程共享进程的堆和方法区资源，私有自己的程序计数器，虚拟机栈和本地方法栈，线程在切换的时候负担比进程小得多。</li>
<li>线程的生命周期有六个状态，分别是新建、就绪、运行、阻塞、死亡。</li>
<li>上下文切换是指 CPU 时间片切换到另一个任务前会先保存自己的状态，以便下次再切换回这个任务是可以再加载这个任务的状态，也就是说任务的保存再到加载的过程就是一次上下文切换。</li>
</ul>
<h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="==synchronized 关键字=="></a>==synchronized 关键字==</h3><ul>
<li>synchronized 关键字是 JVM 层面的操作，它修饰实例方法的时候锁住的是一个对象，修饰静态方法和代码块的时候锁住的是当前类。synchronized 同步语句块用的是 monitorenter 和 monitorexit 指令，两个分别指向代码块的头和尾，线程试图获取锁其实就是试图获取 monitor 对象，monitor 对象存在于每个 java 对象的对象头中，如果锁计数器为 0，执行 monitorenter 指令的时候锁计数器会置 1，这时候其他线程试图获取就会失败，当我们执行到 monitorexit 指令的时候，锁计数器就会置 0，表示锁被释放。synchronized 同步方法的时候用的是 ACC_SYNCHRONIZED 标识，它告诉 JVM 这个方法是不是一个同步方法，然后再执行相应的同步操作。</li>
<li>在 jdk1.6 的时候 synchronized 进行了优化，引入了偏向锁、轻量级锁、自旋锁、重量级锁这些，最开始的时候资源是无锁状态，当出现第一个线程要获取锁的时候锁就会升级为偏向锁，偏向于这个线程，意思就是在没有被其他尝试获取的时候取消同步。如果出现锁竞争比较激烈的情况，每次持有锁的线程可能都不一样，那锁就会升级为轻量级锁，轻量级锁是采用了 CAS 操作来替代互斥量。如果轻量级锁失败以后，为了避免线程在操作系统层面挂起，还加入了一层锁自旋的手段，就是争夺锁的线程进入忙循环的状态，因为一般线程持有锁的时间不会太长，所以让进行一个原地自旋等待能减小开销，但是如果超过一定的自旋次数还没获得，锁就会升级为重量级锁了，因为长时间的原地自旋对 CPU 也是一种消耗，这个升级的过程是不可逆的。</li>
<li>自适应自旋就是根据上一次锁的自旋时间和拥有者的状态来决定这次的自旋时间，锁消除就是 JVM 在编译的时候检测到共享数据不存在竞争了，就把锁给消除。</li>
<li>它和 ReentrantLock 的区别：两者都是可重入锁，就是自己可以再次获取自己内部的锁，获取之后锁计数器会再次加一，释放了减一，一直到锁计数器为零了算是完全释放。synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API，也就是说 ReentrantLock 是 JDK 层面实现的，需要 lock 和 unlock 来手动实现，而 synchronized 则是自动释放。除此之外还有一个就是 ReentrantLock 增加了一些新的功能，比如等待可中断，也就是说等待的线程可以选择放弃等待改为处理其他事情。可实现公平锁，它可以指定锁是公平锁还是非公平锁，而 synchronized 只能是非公平锁，公平锁就是先等待的线程先获取锁。可实现选择性通知，就是 ReentrantLock 可以在 Condition 里指明要通知的线程对象，而 synchronized 则是在 notify 和 notifyall 的时候通知的对象由 JVM 选择。</li>
</ul>
<hr>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="==volatile 关键字=="></a>==volatile 关键字==</h3><ul>
<li>volatile 关键字修饰的变量能保证对不同线程的可见性，它越过了本地内存，直接将变量写入主存中，读取也是直接从主存中读取。因为我们知道 java 的内存模型里，线程和主存之间还存在一个工作内存，如果一个线程在主存中修改了一个变量，而另一个线程还在使用这个变量在本地内存中的拷贝，就会造成数据的不一致，所以 volatile 关键字很好地解决了这种问题。它还有一个作用就是防止指令重排。但是 volatile 只能保证单词读写的原子性，对于 i++这样的操作不能保证它的原子性，要解决这个问题我们可以使用锁或者是原子类。volatile 关键字的底层是对总线上传输的数据不断进行嗅探和 CAS 循环，如果大量使用 volatile 可能会引起总线风暴。</li>
<li>总线嗅探：这个要从缓存一致性原则说起，因为 CPU 和主存之间我们设置了多级缓存，而 CPU 操作的是缓存中的数据，这就有可能会出现多个 CPU 操作的缓存数据不一致的情况，因此设置了缓存一致性原则，就是每个处理器不断对总线上传播的数据进行嗅探，来检查自己的数据是不是过期了，如果发现缓存行对应的内存地址不一致，就会将缓存行置为无效，要操作这个数据时会从主存中重新读取。</li>
<li>禁止指令重排：JVM 会对指令进行重排序，在不改变程序结果的情况下提高效率，遵守 as-if-serial 原则（不管怎么重排序，单线程下的执行结果不能被改变）。而 volatile 关键字实现禁止指令重排是通过插入内存屏障的方式，volatile 写是分别在指令前后加上内存屏障，读是在后面加上两个。<br>-happens-before 原则：一个操作 happens-before 于另一个操作那么第一个操作的结果将对第二个操作可见，如果两个操作之间存在 happens-before 关系，那么如果出现指令重排后的结果和 happens-before 一样，那么这种重排是允许的。</li>
</ul>
<hr>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="==CAS=="></a>==CAS==</h3><ul>
<li>CAS 就是字面上的意思，compare and swap ，它有三个操作数，内存地址 V，旧的预期值 A 和新的目标值 B，当我们在进行 CAS 操作的时候，会比较内存地址 V 里面的值和旧的预期值 A 是否相等，如果相等就可以把 V 里面的值修改为 B，否则就什么都不做。它存在了一些问题，比如我们通常将 CAS 搭配循环来使用，循环时间长了 CPU 的开销会很大。还有就是只能保证一个变量的原子性，还有一个就是 ABA 问题，就是比如我在内存地址 V 中初次读取到的值为 A，准备赋值的时候检查到它的值还是为 A，但是实际上在这个中间它被修改过又改回来了，这样我们是检查不到的，解决这个问题的办法可以是加上一个标识符或者版本号来解决。</li>
</ul>
<hr>
<h3 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="==synchronized 和 volatile 的区别=="></a>==synchronized 和 volatile 的区别==</h3><ul>
<li>volatile 关键字只能用于变量 synchronized 可以用在方法和代码块上。多线程访问 volatile 不会发生阻塞，synchronized 就会。还有就是 volatile 能保证数据的可见性，但不能保证原子性，synchronized 两个都能保证。</li>
</ul>
<hr>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="==ThreadLocal=="></a>==ThreadLocal==</h3><ul>
<li>ThreadLocal 就是线程专属本地变量，就是说如果我创建了一个 ThreadLocal 变量，那每一个访问这个变量的线程都会有这个变量的本地副本，并且通过 get 和 set 方法来获取或设置。它的底层原理是我们的 ThreadLocal 内部存在一个 ThreadLocalMap 静态内部类，它类似于 HashMap，我们存储的 key 是当前的 ThreadLocal 对象，值是我们想要存储的任意值，Thread 对象保持着对 ThreadLocalMap 的弱引用。ThreadLocal 存在一个内存泄漏的问题，因为我们设置的 key 是 ThreadLocal 的弱引用，而 value 是强引用，在我们的 ThreadLocal 没有被外部强引用的情况下 GC 的时候 key 就会被清理，留下 key 为 null 的 value，无法被访问，这时候就出现了内存泄漏。ThreadLocalMap 其实考虑了这种情况，在调用 set、get、remove 方法的时候就会清理掉 key 为 null 的记录，不过还是在使用完 ThreadLocal 后手动调用一个 remove 方法比较好。</li>
<li>为什么是弱引用？因为如果 ThreadLocalMap 持有 ThreadLocal 的强引用，如果 ThreadLocal 的对象回收了，如果我们不手动删除，ThreadLocal 仍然不会被回收这里就出现了内存泄漏。而如果是弱引用，ThreadLocal 的对象被回收了，留下了 key 为 null 的 value，这里就出现了内存泄漏，但是两者不同的地方在于，因为 ThreadLocalMap 生命周期和 Thread 一样长，强引用如果不手动删除就会一直存在，而弱引用多了一层保障，就是在我们下次调用 set、get、remove 的时候就会清除。</li>
</ul>
<hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="==线程池=="></a>==线程池==</h3><ul>
<li>线程池好啊，它是管理线程的一种手段，通过重复利用已创建的线程来降低创建和销毁线程的损耗，提高响应速度还对线程进行统一的分配和监控。它有三个比较重要的参数，一个是核心线程数，一个是最大线程数，一个是缓冲队列。它的线程复用是通过重写 Thread 类，在 start 方法里不断循环调用传过来的 Runnable 对象来实现线程的复用。它的工作过程是，当我们调用 excute 方法添加一个任务时，如果这时的任务书小于核心线程数，那就马上创建线程运行这个任务，如果大于核心线程数，就把它放进缓冲队列里，如果缓冲队列满了，但小于最大线程数，那就创建非核心线程来执行，如果超过了最大线程数就会抛出拒绝添加的异常了，在线程池完成所有工作后，它最终会收缩到核心线程数的大小。</li>
<li>拒绝策略吗？我了解的不多，知道一个是丢弃最老的一个请求，一个是默默丢弃无法处理的请求，还有一个是直接抛出异常。</li>
<li>缓冲队列吗？我记得常用的有两个，一个是 LinkedBlockingQueue，它是无界的，可能会内存溢出。一个是 ArrayBlockingQueue，有界的，通过加锁保证安全，队列不满就唤醒。</li>
<li>线程池参数设置：根据三个参数来判断，一个是 tasks（每秒需要处理的最大任务数量），一个是 tasktime（单线程执行任务耗时），一个是 responsetime（系统允许任务的最大响应时间），举个例子就是比如我有 100 到 1000 个任务，每个人物的 tasktime 是 0.1 秒，那我就需要 10 到 100 个线程，那么我的核心线程数（corePoolSize）就设置为 10 个，具体数字还有个 8020 原则，就是 80%的情况下每秒任务数，就是看 80%的情况下每秒任务数是多少，如果是 200，那 corePoolSize 就设置成 20。然后第二个就是缓冲队列的长度，长度是根据你的核心线程数来设定的，比如刚才算出来的 corePoolSize 是 20，那就用 20/0.1 再*2，就是 400，最后一个就是最线程数，最大线程数就是用刚才最大的 1000 个任务减去缓冲队列的 400 个再乘上 0.1，就是 60 个。keepalivetime 可以根据任务峰值持续时间来设定。</li>
</ul>
<hr>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="==AQS=="></a>==AQS==</h3><ul>
<li>AQS 是 AbstractQueuedSynchronizer，是一个构建锁和同步器的框架，内部是一个 volatile 修饰的 state 变量和一个 FIFO 队列，然后很多并发类比如 ReentrantLock、CountDownLatch、CyclicBarrier 都是基于它实现的，比如 ReentrantLock，它把 state 初始化为 0，表示为未锁状态，一个线程 lock 时调用 tryAcquire 方法独占这个锁并将 state+1，然后其他线程再 tryAcquire 的时候就会失败，直到 unlock 到 state=0。其他两个我就没有深入看过了。</li>
</ul>
<hr>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="==JVM=="></a>==JVM==</h2><h3 id="Java-内存"><a href="#Java-内存" class="headerlink" title="==Java 内存=="></a>==Java 内存==</h3><ul>
<li>Java 的内存空间分为五个部分，分别是堆，方法区，程序计数器，虚拟机栈，本地方法区。堆和方法区是线程共享的，虚拟机栈，程序计数器，本地方法区是线程私有的。堆存放我们的对象以及数组，方法区放的是我们的类信息、常量（static final）、静态变量（static）。程序计数器是线程的字节码解释器，它取出指定指令地址中的指令来执行，然后指向下一条地址，虚拟机栈中有我们的局部变量表、操作数栈、动态链接、方法出口等，局部变量表主要存放了我们的八种基本数据类型（short,int,long,float,double,char,boolean,byte）以及对象引用。</li>
</ul>
<hr>
<h3 id="Java-类加载过程"><a href="#Java-类加载过程" class="headerlink" title="==Java 类加载过程=="></a>==Java 类加载过程==</h3><ul>
<li>类的加载过程是加载，验证，准备，解析，初始化，卸载，这个过程中我们还用到一个双亲委派原则，就是当类加载器收到一个类加载请求的时候，它首先会把这个请求交给父类加载器，如果父类加载器处理不了才会自己尝试加载。</li>
<li>Java 的类加载器有，最顶层是 Bootstrap ClassLoader，这是虚拟机识别的类库用户无法直接使用，然后是 Extension ClassLoader 用户可以使用，然后是 Application ClassLoader，负责的是用户路径中的所有类库，如果用户没有自定义加载器那就默认使用这个，最后才到自定义类加载器。自定义类加载器的原因是系统加载器只加载指定目录下的 class 文件，如果想加载自己定义的 class 文件就可以自己定义一个。</li>
</ul>
<hr>
<h3 id="Java-对象创建的过程"><a href="#Java-对象创建的过程" class="headerlink" title="==Java 对象创建的过程=="></a>==Java 对象创建的过程==</h3><ul>
<li>==类加载检查==到==分配内存==到==初始化零值==到==设置对象头==到执行==init 方法==</li>
<li>首先是类加载的过程，JVM 遇到一条 new 指令时首先会去检查这个指令的参数能不能在常量池中定位到这个类的符号引用，并且检查这个类有没有被加载解析初始化过，如果没有就要执行相应的加载过程。</li>
<li>然后是分配内存，在堆的新生代里划分一块内存给新生的对象，分配方法有指针碰撞法和空闲列表法。</li>
<li>然后是初始化零值，JVM 将分配到的内存空间都初始化为零值。</li>
<li>然后设置对象头，对象头包括了 Mark Word，Klass Point，Monitor，Mark Word 里有对象的 HashCode，分代年龄还有锁标志位信息，Klass Point 是指向类元数据的指针，Monitor 就是之前说的 synchronized 方法操作的地方。</li>
<li>最后就是执行 init 方法，把对象按照我们的写法初始化。</li>
</ul>
<hr>
<h3 id="JavaGC"><a href="#JavaGC" class="headerlink" title="==JavaGC=="></a>==JavaGC==</h3><ul>
<li>从 GC 的角度我们的堆还分为新生代和老年代，新生代还分为 eden、servivorFrom、servivorTo，Eden 是 Java 新对象的初始地带，如果对象比较大就会直接进入老年区，当 Eden 区不够的时候就会触发一次 MinorGC，结束之后如果对象还存活就会进入到 servivorFrom 或者 servivorTo 区，同时年龄加一，当年龄增加到一定程度之后就会进入老年区了。老年区存放的是比较稳定生命周期比较长的对象，老年区空间不够了就会触发 MajorGC。最后还有一个就是永久代，永久代存放的就是类和元数据信息，永远不会被 GC。</li>
<li>GC 通过两种方法确定垃圾，一个是引用计数法一个是可达性分析法，引用计数法就是给对象添加一个引用计数器，每当有一个地方引用他计数器就加一，引用失效就减一，当计数器为零就是可以回收的对象了。而可达性分析法就是从 GCRoot 节点出发一直到我们的对象，走过的路径就是引用链，如果对象到 GCRoot 没有一条引用链就说明这个对象是可回收的。</li>
<li>确定了垃圾之后就是回收算法，JVM 主要有三种回收算法，一个是标记清除算法，就是把需要回收的对象打上标记，然后回收，缺点是碎片化比较严重，复制算法是 MinorGC 用的，它是把内存划分为等大小的两块，每次只用其中一块，当内存空间满了之后就把存活对象复制到另一块上区，然后把这一块全都清除，问题就是可用内存变为了原来的一半。标记整理算法是标记可回收对象，然后让所有存活对象向一端移动，然耨清理掉端以外的内存。</li>
<li>对象引用有四种，强引用，软引用，弱引用，虚引用，一个对象如果具有强引用，它就不可被回收，如果具有的是软引用，那在内存空间足够的时候，它不会被回收，如果内存空间不足了，它就会被回收。而弱引用是存活的时间更短一点，如果被垃圾回收器扫描到，就会被回收。虚引用基本就跟没有一样，任何时候都有可能被回收。</li>
</ul>
<hr>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="==垃圾收集器=="></a>==垃圾收集器==</h3><p>垃圾收集器了解的不多，只知道</p>
<ul>
<li>CMS 收集器，CMS 收集器采用多线程标记清除算法，分为四个阶段，首先是初始标记阶段，这个阶段很快，只是标记一下 GCRoot 可达对象，但是会暂停所有工作线程，然后时并发标记阶段，这个过程是进行 GCRoots 跟踪，能和用户线程一起工作，重新标记阶段，对并发标记阶段的记录进行修正，最后是并发清除，和用户线程一起工作，清除不可达对象。</li>
</ul>
<hr>

  </section>

  <section class="post-comments">
  <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
</section>



</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno" target="_blank" rel="noopener">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/jquery.min.js"></script>
    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
