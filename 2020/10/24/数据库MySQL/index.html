<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      MySQL | Blog of Alaga 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="朱邦政">
    
    

    <meta name="description" content="MySQL 是什么？一个关系型数据库。  数据库的三范式 第一范式（1NF）：数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。解释：列不可分。第二范式（2NF）：在第一范式的基础上，要求实体的属性完全依赖于主关键字。解释：不能部分依赖。即：一张表存在组合主键时，其他非主键字段不能部分依赖。第三范式（3NF）：在第二范式的基础上，要">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL | Blog of Alaga">
<meta property="og:url" content="http://yoursite.com/2020/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL/index.html">
<meta property="og:site_name" content="Blog of Alaga">
<meta property="og:description" content="MySQL 是什么？一个关系型数据库。  数据库的三范式 第一范式（1NF）：数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。解释：列不可分。第二范式（2NF）：在第一范式的基础上，要求实体的属性完全依赖于主关键字。解释：不能部分依赖。即：一张表存在组合主键时，其他非主键字段不能部分依赖。第三范式（3NF）：在第二范式的基础上，要">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-10-24T09:46:04.000Z">
<meta property="article:modified_time" content="2020-10-24T16:26:34.219Z">
<meta property="article:author" content="朱邦政">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    
<link rel="stylesheet" href="/css/uno.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    
<link rel="stylesheet" href="/css/archive.css">

    
<link rel="stylesheet" href="/css/china-social-icon.css">


<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Blog of Alaga" type="application/atom+xml">
</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Blog of Alaga</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->




        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">MySQL</h1>

    

    <div class="post-meta">
      <time datetime="2020-10-24" class="post-meta__date date">2020-10-24</time> 

      <span class="post-meta__tags tags">

          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
            </font>
          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/MySQL/" rel="tag">MySQL</a>, <a class="tags-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a>, <a class="tags-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h2 id="MySQL-是什么？"><a href="#MySQL-是什么？" class="headerlink" title="MySQL 是什么？"></a>MySQL 是什么？</h2><p>一个关系型数据库。</p>
<hr>
<h2 id="数据库的三范式"><a href="#数据库的三范式" class="headerlink" title="数据库的三范式"></a>数据库的三范式</h2><ul>
<li>第一范式（1NF）：数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。<strong><em>解释</em></strong>：列不可分。<br>第二范式（2NF）：在第一范式的基础上，要求实体的属性完全依赖于主关键字。<strong><em>解释</em></strong>：不能部分依赖。即：一张表存在组合主键时，其他非主键字段不能部分依赖。<br>第三范式（3NF）：在第二范式的基础上，要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。<strong><em>解释</em></strong>：不能存在传递依赖。即：除主键外，其他字段必须依赖主键。</li>
</ul>
<hr>
<h2 id="数据库的索引"><a href="#数据库的索引" class="headerlink" title="数据库的索引"></a>数据库的索引</h2><ul>
<li>数据库的索引其实就是为了让数据库查询更快的一种排好序的数据结构。分为普通索引、唯一索引、主键索引、聚合索引、全文索引。<ul>
<li>普通索引没有什么限制，是基本的索引类型，仅起到加速查询的作用。</li>
<li>唯一索引不允许两行有相同的索引值，一张表中可以有多个唯一索引。</li>
<li>主键索引是一种特殊的唯一索引，一张表中只能有一个主键索引。</li>
<li>联合索引是可以覆盖多个数据列的索引。</li>
<li>全文索引是把一个大文本段当作一个索引。<br><strong>以上几种索引的区别：</strong><br><strong>主键索引和普通索引</strong>：主键索引在 B+树上的叶子节点存放的是整行数据，而普通索引的叶子节点存放的是主键的值，主键索引我们直接搜寻 B+树就可以得到，但普通索引我们得到了主键的值以后还要回表再搜寻一次，效率比较低。<br><strong>主键索引和唯一索引</strong>：一张表中只能有一个主键索引，可以有多个唯一索引。主键索引不可以为空，唯一索引可以为空。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="数据库的引擎"><a href="#数据库的引擎" class="headerlink" title="数据库的引擎"></a>数据库的引擎</h2><ul>
<li>MySQL 引擎分为<strong>MYISAM</strong>和<strong>InnoDB</strong>，在 mysql-5.1 版本之前默认引擎是 MyISAM，5.1 之后是 innoDB。<br><strong>二者区别：</strong><ul>
<li>MYISAM：不支持外键、事务和 MVCC，使用表锁，查询表行数的时候不需要全表扫描。</li>
<li>InnoDB：支持外键、事务和 MVCC，使用行锁，查询表行数的时候需要全表扫描。</li>
<li>这两个的区别除了上面说的几个以外还有索引方面的区别，InnoDB 的数据文件本身就是索引文件，它的辅助索引 data 域存储的是主键的值而不是地址，而 MYISAM 的索引和数据文件是分开的，辅助索引和主索引没多大区别。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><ul>
<li>InnoDB 用的数据结构是 B+树，它是由 B 树优化而来的。<ul>
<li><strong>B+树的构造</strong>：B+树的非叶子节点上不保存指向关键字的指针，仅仅作为索引，因此能容纳的关键字数量就更多，树的高度就比 B 树更矮，然后我们磁盘 IO 的效率就更高。它的叶子节点上保存了所有父节点关键字的指针，叶子节点根据关键字的大小从小到大排列，叶子节点之间存在指针指向下一个节点，相当于一个有序链表，对 B+树进行查找相当于二分查找，时间复杂度相对稳定，是 logn，无论是否成功，都要经历从根节点到叶子节点的路径。</li>
<li><strong>B+树和 B 树的区别</strong>：<br>1、B 树的每个节点都存储数据，非叶子节点存储关键字和指向关键字的指针，如果要存储大量的数据那树的高度就会上来，效率就变低了。<br>2、B 树的查询是要遍历每一层的节点，如果我们要查询的信息离根节点很近，那时间复杂度就很低，可能是 O（1），如果很远，那就是 O（n）了。<br>3、而 B+树的叶子节点保存了所有信息，非叶子节点作为索引不保存指向关键字的指针，因此能容纳更多的关键字，树的高度就更矮，磁盘 IO 次数就更少。它的叶子节点根据关键字的大小从小到大排列，并且叶子节点之间还有指向下一个节点的指针，查询的时候相当于对叶子节点进行遍历，在非叶子节点的帮助下我们的查询效率相当于二分查找，相对稳定，是 O（logn）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="数据库的事务"><a href="#数据库的事务" class="headerlink" title="数据库的事务"></a>数据库的事务</h2><ul>
<li>A 是 Atomicity 原子性，原子性就是事务应该是一个不可分割的工作单位，事务中的操作要么都执行要么都不执行</li>
<li>C 是 Consistency 一致性，事务前后数据的完整性都保持一致。</li>
<li>I 是 Isolation 隔离性，是指事务并发的时候相互隔离互不干扰。</li>
<li>D 是 Durability 持久性，指事物提交后对数据的操作应该是永久性的。</li>
</ul>
<hr>
<h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><ul>
<li>数据库的隔离级别有四种，从一致性低到高（并发性从高到低）为<ul>
<li>读未提交</li>
<li>读已提交</li>
<li>重复读</li>
<li>串行化<br>不考虑隔离级别的话会导致脏读、不可重复读和幻读的出现。<br>脏读就是一个事物读到了其他事务未提交的数据，也就是脏数据。不可重复读就是指一个事物多次查询同一个数据得到的结果是不同的，因为被其他事务修改过，幻读是也是读到了其他事物处理过的数据，但是和不可重复读的地方在于幻读针对是一批数据集合。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="SQL-调优"><a href="#SQL-调优" class="headerlink" title="SQL 调优"></a>SQL 调优</h2><p>1、最基本的是表要有主键，有主键的表 MySQL 会创建聚簇索引，聚簇索引有一个好处就是主键和数据行是在一起的，你在 explain 查询的时候会发现它的 type 级别是 constant，这是很高的一种级别。<br>2、当有主键的时候一条 SQL 语句查询很慢可以查看它是否建立了相应的索引，索引的选择可以尽量是 where、orderby、groupby 以及 join 后面的字段作为索引列，并且这些索引列要排个序，符合最左匹配原则（最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配）<br>3、另外呢就是你选的时候要根据它们的索引选择器，你的非重复数据行和重复数据行间的排列，大的放左小的放右的形式，然后这种多列的形式尽量去建立联合索引而非多个单个索引。<br>4、如果数据查询比较频繁，就可以使用覆盖索引。关于索引没有生效的问题，也可以考虑一下 MySQL 底层是不是出了什么问题，因为它底层是一个随机采样的过程，它会根据你的索引基数采样，但是它不可能给你全部标记上，它会根据随机采样来计算你的索引选择，有可能它采错了，虽然你的索引选择性比较大，但是它可能认为你的选择性比较小，然后就出错了，对于这种情况一般是用 force index 让它强制走看它行不行，如果不行的话就要刷新一下它的信息了用 analyze table 看它有没有重新走对。</p>
<hr>
<h2 id="数据库死锁"><a href="#数据库死锁" class="headerlink" title="数据库死锁"></a>数据库死锁</h2><ul>
<li><strong>现象</strong>：程序在执行的过程中，点击确定或保存按钮，程序没有响应，也没有出现报错。<br><strong>场景</strong>：当对于数据库某个表的某一列做更新或删除等操作，执行完毕后该条语句不提交，另一条对于这一列数据做更新操作的语句在执行的时候就会处于等待状态，此时的现象是这条语句一直在执行，但一直没有执行成功，也没有报错。<br><strong>原因</strong>：<br>1、<strong><em>事务之间对资源访问顺序的交替</em></strong>：一个用户 A 访问表 A（锁住了表 A），然后又访问表 B；另一个用户 B 访问表 B（锁住了表 B），然后企图访问表 A；这时用户 A 由于用户 B 已经锁住表 B，它必须等待用户 B 释放表 B 才能继续，同样用户 B 要等用户 A 释放表 A 才能继续，这就死锁就产生了。<br>这种死锁比较常见，是由于程序的 BUG 产生的，除了调整的程序的逻辑没有其它的办法。<br>2、<strong><em>并发修改同一记录</em></strong>：用户 A 查询一条纪录，然后修改该条纪录；这时用户 B 修改该条纪录，这时用户 A 的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户 B 里的独占锁由于 A 有共享锁存在所以必须等 A 释放掉共享锁，而 A 由于 B 的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。<br>这种死锁的解决办法一般是通过乐观锁来解决，通过加一个版本号（Version）来实现。<br><strong>定位</strong>：select username,<strong>lockwait</strong>,status,machine,program from v$session where sid in (select session_id from v$locked_object)<br><strong>解决</strong>：一般情况下只需要将死锁的语句提交就好了，但是如果定位不到语句的话把程序关闭重启就好</li>
</ul>

  </section>

  <section class="post-comments">
  <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
</section>



</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno" target="_blank" rel="noopener">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/jquery.min.js"></script>
    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
